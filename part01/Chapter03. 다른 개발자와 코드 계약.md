# 3. 다른 개발자와 코드 계약

## 3.1 자신의 코드와 다른 개발자의 코드

`1인 개발자 회사에서 일하지 않는 한 다른 개발자들을 고려하지 않고는 고품질의 코드를 작성할 수 없다`

### 3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다

자신의 로직에 너무 익숙해서 모든 것이 분명해 보이기 때문에 어떤 것이 왜 그런 방식인지, 문제를 왜 그 방식으로 해결하고 있는지에 대해서는

거의 생각하지 않아도 될 것이다. 하지만 어느 시점에 이르면 다른 개발자가 내가 작성한 코드와 상호작용하거나, 내 코드를 변경하거나,

내 코드가 의존하고 있는 코드를 변경해야 할 수도 있다는 것을 기억해야한다.

이것을 항상 고려하고 코드가 어떻게 사용되어야 하는지, 무엇을 하는지, 그리고 왜 그 일을 하고 있는지 설명하는 것이 유용하다.

주석문을 많이 작성해야 한다는 의미는 아니다. 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다

### 3.1.2 다른 개발자는 무의식중에 나의 코드를 망가뜨릴 수 있다.

우리가 작성한 코드는 독립적으로 존재하지 않는다. 여러 가지 다른 코드에 의존할 것이고, 그 코드는 또다시 더 많은 다른 코드에 의존할 것이다.

다른 개발자가 기능을 추가하고, 리팩터링하고 수정함에 따라 이들 코드는 계속 변한다. 따라서 우리가 작성한 코드는 다른 코드로부터 전혀 영향을 받지 않은 채

독립적으로 잇는 것이 아니라, 끊임 없이 변화하는 코드 위에 놓여있고, 우리의 코드를 기반으로 계속해서 변화하는 코드 역시 끊임없이 작성된다

### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다.

자신에게는 분명한데 다른 사람에게는 분명하지 않을 수 있다는 것, 혹은 다른 사람들이 무의식중에 자신의 코드를 작동하지 않게 만드는 것과

관련해 살펴본 모든 내용이 어느순간 자신에게 적용된다. 배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬워야 하고,

잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다. 이렇게 하는 것은 다른사람에게 호의를 베푸는 것이면서 미래의 자신에게도 유익한것이다.

## 3.2 우리가 작성한 코드의 사용법을 다른사람들은 어떻게 아는가?

다른 개발자가 우리의 코드를 사용하거나 우리의 코드에 의존하는 코드를 수정할 때, 그들은 우리의 코드를 어떻게 사용해야 하는지 그 코드가 무슨일을

하는지 파악해야 한다. 구체적으로 그들은 다음과 같은 사항을 이해할 필요가 있다

- 여러 가지 상황에서 어떤 함수를 호출해야 하는지
- 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
- 어떤 값을 인수로 사용해야 하는지
- 코드가 수행하는 동작이 무엇인지
- 어떤 값을 반환하는지

우리가 작성한 코드를 어떻게 사용해야 하는지 알아내기 위해 다른 개발자가 할 수 있는 일은 다음과 같다

- 함수, 클래스, 열거형 등의 이름을 살펴본다
- 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다
- 함수/클래스 수준의 문서나 주석문을 읽어본다
- 직접 와서 묻거나 채팅/이메일을 통해 문의한다
- 우리가 작성한 함수와 클래스의 자세한 구현 코드를 읽는다

사실 이 중 처음 세가지만 실제로 사용할 만하고 그 중에서도 이름과 데이터 유형을 확인하는 것이 문서를 읽는 것보다 더 신뢰할 만하다

### 3.2.1 이름 확인

이름을 살펴보는 것은 개발자들이 새로운 코드의사용 방법을 알아내기 위해 실제로 사용하는 주된 방법 중 하나다.

`removeEntry()`라는 이름의 함수는 `addEntry()`라는 이름의 함수와 혼동할 수 없다.

따라서 자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는것이다.

### 3.2.2 데이터 유형 확인

데이터 유형을 확인하는 것 역시 다른 개발자로 하여금 자신의 코드를 올바르게 사용하도록 하기 위한 매우 신뢰할 만한 방법이다.

컴파일이 필요한 정적 유형의 언어에서는 데이터 유형을 인식하고 올바르게 사용해야 한다. 그렇지 않으면 코드가 컴파일 되지 않는다.

따라서 유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법 중 하나다

### 3.2.3 문서 읽기

- 함수 및 클래스 수준의 비공식적인 주석문
- 자바독(JavaDoc)과 같은 좀 더 공식적인 코드 내 문서
- 외부 문서(README.md, 웹페이지 등)

### 3.2.4 직접 물어보기

### 3.2.5 코드를 살펴보기

## 3.3 코드 계약

`계약에 의한 프로그래밍` 또는 `계약에 의한 디자인`이라는 용어를 접해 본 적 있을 것이다. 이이 원칙은 다른 사람들이 어떻게 코드를 사용할지,

그리고 코드가 무엇을 할 것으로 기대할 수 있는지에 대한 것이다. 이 철학은 서로 다른 코드간의 상호작용을 마치 계약처럼 생각한다.

코드의 계약에 대한 용어를 다음과 같은 세 가지 범주로 나누면 유용하다

- `선결 조건` : 코드를 호출하기 전에 사실이어야 하는 것, 예를 들어 시스템이 어떤 상태에 있어야 하는지 같은 상황
- `사후 조건` : 코드가 호출된 후에 사실이어야 하는 것 , 예를 들어 시스템이 새로운 상태에 놓인다는지 반환되는 값과 같은 사항
- `불변 사항` : 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

### 3.3.1 계약의 세부 조항

전기 스쿠터 렌털 앱 계약을 예로 보자. 이 계약은 명백한 사항과 세부 조항으로 나눌 수 있다

- 명백한 사항
  - 전기 스쿠터를 빌린다
  - 임대료는 시간당 10달러다
- 계약의 세부 조항.
  - 충돌 사고 시 수리 비용을 지불해야 한다
  - 시 경계를 넘어서면 100달러의 벌금이 부과된다 등.

이와 비슷하게 코드에서 계약을 정의할 때도 명확한 부분과 세부 조항이 있다

- 계약의 명백한 부분
  - `함수와 클래스 이름` : 호출하는 쪽에서 이것을 모르면 코드를 사용할 수 없다
  - `인자 유형` : 호출하는 쪽에서 유형을 잘못 사용하면 코드는 컴파일조차 되지 않는다
  - `반환 유형` : 호출하는 쪽에서 함수의 반환 유형을 알아야 한다. 이 유형과 일치하지 않는 유형을 사용하면 컴파일되지 않음
  - `검사 예외 (checked exception)` : 호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일 되지 않는다

- 세부 조항
  - `주석문과 문서` : 실제 꼐약의 세부조항에 대해 그렇듯 꼼꼼하게 모두 다 읽어봐야하는 것임에도 실제로는 잘 읽지 않는다

    개발자는 이 사실을 실용적인 관점에서 봐야한다
  - `비검사 예외(unchecked exception)` : 주석문에 이 예외가 나열되어 있다면 이것은 세부 조항이다.

코드 계약에서 조건을 명백하게 하는 것이 세부 조항을 사용하는 것보다 훨씬 낫다. 사람들은 세부 조항을 읽지않는 경우가 매우 많으며,

심지어 읽더라도 그것을 대충 훑어보기에 잘못 이해할 수 있다. 또한 문서화는 업데이트가 제때 되지 않기 때문에 세부 조항이 항상 정확한것도 아니다

### 3.3.2 세부 조항에 너무 의존하지 말라

세부 조항에 의존하는 것을 피할 수 없는 경우도 있다. 어떤 문제들은 항상 주의 사항이 있고 이것을 설명해야 한다.

```kotlin
class UserSettings {
    constructor(
        ...
    )
    
    // 이 함수를 사용해 설정이 올바르게 로드 되기 전까지는 다른 어떤함수도
    // 호출해서는 안된다.
    fun loadSettings(location: File) : Boolean {
        ...
    }

    // init()은 다른 함수 호출 이전에 호출해야 하지만
    // loadSettings() 함수 호출 이후에만 호출해야 한다
    fun init() {
        ...
    }

    // 사용자가 선택한 UI의 색상을 반환한다
    // 선택된 색상이 없거나 설정이 로드되지 않았거나 초기화 되지 않은
    // 상태라면 널을 반환한다
    fun getUiColor() : Color?{

    }
}
```

이 코드의 계약을 보자

- 명확한 부분
  - 클래스 이름은 UserSettings이다. 따라서 상룡자 설정을 포함하고 있을 것이다
  - getUiColor()는 사용자가 선택한 UI색상을 반환할 것이라는 점이 거의 확실하다. 색상 또는 널을 반환한다
  - loadSettings()는 파일 객체를 매개변수로 받고 불리언 값을 반환한다. 주석문을 읽지않아도 알 수 있다.
- 세부 조항
  - 이 클래스는 구체적은 순서로 함수 호출이 이뤄져야 한다. 첫 번째 loadSettings()을 호출해야한다.

    이 함수가 성공적 호출 후에는 init() 그제야 이 클래스를 사용할 수 있다
  - loadSettings()이 거짓을 반환하면, 이 클래스는 다른 함수들을 호출하면 안 된다.
  - getUiColor()가 널값을 반환하면 이것은 사용자가 색상을 선택하지 않았거나 클래스가 아직 설정되지 않았음을 의미한다

이 클래스의 계약은 바람직하지 않다. 이 클래스를 사용하는 개발자가 모든 세부 조항, 즉 주석문을 주의 깊게 읽지 않으면

이 클래스를 올바르게 서렁하지 못할 가능성이 크다.

이게 어떤 문제가 될 수 있냐면 다음 코드를 보자

```kotlin
fun setUiColor(userSettings : UserSettings) {
    val chosenColor : Color? = userSettings.getUiColor()
    
    if (chosenColor == null) {
        ui.setColor(DEFAULT_UI_COLOR)
        return
    }
    ui.setColor(chosenColor)
}
```

setUiColor() 함수를 호출하기 전에 userSetting이 올바르게 설정되어 있지 않더라도 프로그램은 계속 동작할 것이고

모호하더라도 무언가를 수행하지만 여기는 분명히 버그가 발생한다. 즉, 사용자가 선택한 UI색상이 존재하더라도 이것이 무시된다.

`세부 조항을 제거하는 방법`

다른 개발자가 코드를 올바르게 사용하기 위해 세부 조항에 의존하기보다 잘못된 일을 하는 것을 처음부터 불가능하게 만드는 것이 좋다.

UserSetting 클래스는 정적 팩토리 함수를 사용해 초기화가 완전히 이루어진 인스턴스를 얻는 것만 가능하도록 수정할 수 있다.

세부 조항이 거의 없는 카드는 다음과 같다

```kotlin
class UserSettings {
    constructor{
        ...
    }

    companion object {
        fun create(location) : UserSettings? {
            val settings = UserSettings()
            if(!settings.loadSettings(location))
                return null
            settings.init()
            return settings
        }
    }
}

fun loadSettings(location: File): Boolean {...}

fun init() {...}

fun getUiColor(): Color? {...}

```


이렇게 변경하면 UserSettings 클래스의 계약에서 거의 모든 숨겨진 세부 조항을 성공적으로 제거하고, 잘못된 상태에서

클래스의 인스턴스를 만드는 것이 불가능해진다. 숨겨진 세부 조항 중 남은 것은 getUiColor()이 널 값을 반환할 때 무엇을

의미하는지 설명하는 것이지만 이조차도 필요하지 않다. 왜냐면 대부분의 사용자는 널 값의 의미를 추측할 수 있고, 더 이상 클래스가

잘못된 상태에 있다는 것을 나타내지 않기 때문이다.

이런 방식은 바로 `상태(state)`나 `가변성(mutability`이 클래스 외부로 노출되는 것을 없앤다는 점이다.

## 3.4 체크 및 어서션

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다. 이 방법은 컴파일 타임 확인만큼

강력하진 않지만 컴파일러를 사용하여 계약을 강제할 수 있는 실질적인 방법이 없는 상황이 더러 있는데 이 경우 런타임 검사를 사용하는 것이 낫다

### 3.4.1 체크

코드의 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다. 체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분된다

- `전제 조건 검사` : 예를 들어 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
- `사후 상태 검사` : 예를 들어 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

```kotlin
class UserSettings {
    constructor(
        ...
    )
    
    // 이 함수를 사용해 설정이 올바르게 로드 되기 전까지는 다른 어떤함수도
    // 호출해서는 안된다.
    fun loadSettings(location: File) : Boolean {
        ...
    }

    // init()은 다른 함수 호출 이전에 호출해야 하지만
    // loadSettings() 함수 호출 이후에만 호출해야 한다
    fun init() {
        if(!haveSettingsBeenLoaded()) {
            throw StateException("Settings not loaded")
        }
    }

    // 사용자가 선택한 UI의 색상을 반환한다
    // 선택된 색상이 없거나 설정이 로드되지 않았거나 초기화 되지 않은
    // 상태라면 널을 반환한다
    fun getUiColor() : Color?{
        if(!hasBeenInitialized()) {
            throw StateException("Settings not initialized")
        }
    }
}
```

이 코드는 버그가 아무도 모르게 발생하는 것을 방지함으로써 세부 조항이 많았던 원래 코드를 개선하는데, 설정이 성공적으로 로드되지 않은 경우에는

로드 실패가 발생한다. 하지만 이것은 오용을 아예 불가능하게 만든 해결책보다는 이상적이지 않다.

체크를 사용할 때 기대하는 것은 코드가 오용되면 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고 수정되는 것이다.

이것은 프로그램이 아무도 눈치채지 못하게 유효하지 못한 상태로 들어가 버그가 발견되지만, 처음에 명백하게 파악되지 않는 상황보다는 낫다.

그러나 체크의 효과가 보장되는 것은 아니다. 경우에 따라 코드 계약에서 세부 조항을 피할 수 없으며, 이때는 계약이 준수되는지 확인하기 위해

체크를 추가하는 것이 좋다. 하지만 가능하다면 처음부터 세부 조항은 피하는 것이 바람직하다. 코드에 체크가 많이 있으면

세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호일지 모른다

### 3.4.2 어서션

많은 언어에서 `어서션(assertion)`은 언어차원에서 지원한다. 어서션은 코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사하다.

코드가 개발 모드에서 컴파일 되거나 테스트가 실행될 때, 어서션은 체크와 거의 같은 방식으로 동작한다.

조건이 위반되면 오류가 명백하게 보이거나 예외가 발생한다. 어서션과 체크사이의 주요 차이점은 배포를 위해 빌드할 때 어서션은 보통

컴파일에서 제외된다는 점이며, 이는 코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 것을 의미한다.

코드를 배포할 때 컴파일하지 않는 이유는 다음과 같다

- `성능 향상을 위해` : 조건이 위반되는지 확인하려면 CPU 사이클이 필요하다. 코드에서 어서션이 많으면 소프트웨어의 전반적인 성능이 눈에 띄게 저하할 수 있다
- `코드 오류 발생률을 낮추기 위해` : 이것이 유효한 동기인지 아닌지는 특정 응용 프로그램에 달려 있다. 이로 인해 버그가 눈에 띄지 않을 가능성이 증가하지만

    버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충이 될 수 있다.

어서션을 사용하면 코드는 다음과 같다

```kotlin
class UserSettings {

    fun getUiColor() : Color? {
        assert(hasBeenInitialized(), "UserSettings가 초기화되지 않음")
    }
}
```

체크에 대해 언급했던 사항은 어서션에도 해당된다. 코드 계약에 세부 조항이 있을 때 어서션을 사용하면 좋다.

하지만 애초에 세부 조항을 피하는 것이 더 바람직하다

# 요약

- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경된다.
- 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있을지 생각해보고, 이러한 가능성을 최소화하거나 오용이 불가능하게 만드는 방식으로

    코드를 작성하는 것이 유용하다
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어진다. 여기에는 명백한 항목이나 세부 조항과 같은 내용이 포함될 수 있다
- 코드 계약의 세부 조항은 다른 개발자가 계약을 준수하도록 하기 위한 방법이지만 신뢰할만한 방법은 아니다

    보통 더 나은 접근법은 명백한 항목으로 계약의 내용을 전달하는 것이다
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법이다.

    이것이 가능하지 않을 때, 체크나 어서션을 사용하여 실행 시간에 계약을 확인할 수 있다.